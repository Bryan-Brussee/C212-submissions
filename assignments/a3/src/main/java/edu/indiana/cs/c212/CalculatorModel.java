package edu.indiana.cs.c212;

/**
 * An instance of this class holds the data used by a Calculator. It has no
 * knowledge of either the View, which displays the controls and the data, nor
 * the Controller, which mediates user interaction with the View.
 * 
 * An instance of this class can be asked to return its memory, to set its
 * memory to a given number, to add a number to its memory, to subtract a number
 * from its memory, to multiply its memory by a number, and to divide its memory
 * by a number.
 * 
 * Since this class is holding the data for a simple 4-function calculator, it
 * only needs one piece of information: a memory of the computation done so far.
 * Thus, its 'memory' only needs to be one number large.
 * 
 * One way to implement this class would be to represent its one number of
 * memory as an int, but that would lead to problems that users of the
 * calculator would notice.
 * 
 * Problem 1: In addToMemory() and multiplyMemoryBy(): both adding and
 * multiplying one huge number by another huge number can result in overflow
 * (that is, the result is so large that it becomes negative, or if its even
 * larger, positive again). Possible fix: intead of representing the memory as
 * an int, represent it as a long and check the range of computed results---or
 * even better, represent it as a double. (Alternately, you might use BigInteger
 * to get arbitrary precision.)
 * 
 * Problem 2: In divideMemoryBy(): underflow, roundoff, and division-by-zero are
 * all possible. Division of a small number by a really large number can result
 * in underflow (that is, the result is indistinguishable from zero and so
 * that's how the result is reported). Further, integer division chops off
 * fractions if the two numbers don't divide evenly. And finally, division by
 * zero produces infinity. Possible fix: convert to long, or better, convert to
 * double and check the result of the division, then do a fix with tests by
 * converting to long instead of int. (Alternately, you could be much more exact
 * by using BigDecimal; or again, just use BigInteger everywhere and get
 * arbitrary precision.)
 * 
 * In general, an arbitrary-precision solution is to use BigInteger everywhere
 * and do all arithmetic yourself. But that would involve more work than is
 * needed for this assignment.
 * 
 * A less general, but good enough, solution (for the high- but still
 * limited-precision work needed for a simple 4-function calculator), is simply
 * to use double instead of int. doubles don't solve all the problems of ints
 * since they too are fixed-precision and fixed-range (just much larger in both
 * cases), but they do push both boundaries out far enough that most ordinary
 * users won't notice (and in the rare cases when they might notice, they mostly
 * won't care).
 * 
 * By switching to doubles, all the methods become single lines, except for the
 * getMemory() method. The only real hairball left would then be to properly
 * handle two special case results when outputting memory (that is, in the
 * getMemory() method).
 * 
 * The two special cases are:
 * 
 * 1/ division-by-zero has occurred somewhere in the operator pipeline, so the
 * memory has become infinite, so whenever getMemory() is next called it has to
 * report: 'infinity.'
 * 
 * 2/ a whole number result has been produced, so the returned result needs to
 * be reported without a decimal point (which is the default for all doubles).
 * For example, on dividing 15 by 5, the result should be reported as '3' not
 * '3.' or '3.0' etc.
 * 
 * For such a simple calculator, a good-enough approximate solution in this case
 * is to assume that the numbers generated by the calculator will all fit into
 * longs. From there you need to figure out how to find the fractional part of
 * the memory (which is a double), then if that fraction is zero, convert the
 * memory to a long (which will chop off its fraction for you). Most users of a
 * simple 4-function calculator will be happy with numbers in the range that fit
 * into longs (-9,223,372,036,854,775,808 to +9,223,372,036,854,775,807).
 */
public class CalculatorModel {
	private double memory;

	public CalculatorModel() {
		memory = 0;
	}
	/*
	 * You have two special tasks to complete in your getMemory method. 
	 * 1. You need to handle division by zero so that your calculator returns
	 * "Infinity" when you divide by zero. 
	 * 2. You need to return integer values	as integers in your String (no decimals).
	 * For example: 6.0/3.0 should return 2 and not 2.0
	 * 
	 * You will need to know Double.toString() or Long.toString() which takes a
	 * double or a long, converts it to a String, and gives you back that String.
	 * 
	 * You may also want to make use of %. a % b gives you the
	 * remainder of a divided by b. For example 11 % 4 = 3
	 */
	public String getMemory() {
		
		//FIXME
		return "I'm broken, please fix me";

	}

	public void setMemory(String string) {
		memory = convertStringToDouble(string);
	}

	public void addToMemory(String string) {
		memory += convertStringToDouble(string);
	}

	public void subtractFromMemory(String string) {
		memory -= convertStringToDouble(string);
	}

	public void multiplyMemoryBy(String string) {
		memory *= convertStringToDouble(string);
	}

	public void divideMemoryBy(String string) {
		memory /= convertStringToDouble(string);
	}

	private double convertStringToDouble(String string) {
		// all inputs are guaranteed to be whole number strings
		// so there's no need to worry about NumberFormatException

		return Double.parseDouble(string);
	}
}
